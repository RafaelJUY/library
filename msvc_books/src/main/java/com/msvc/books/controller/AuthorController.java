package com.msvc.books.controller;

import com.msvc.books.dto.AuthorDto;
import com.msvc.books.dto.BookDto;
import com.msvc.books.exception.ModelKeyAutogeneratedException;
import com.msvc.books.exception.ModelNotFoundException;
import com.msvc.books.model.entity.AuthorEnt;
import com.msvc.books.model.entity.BookEnt;
import com.msvc.books.service.IAuthorService;
import com.msvc.books.service.IBookAuthorService;
import com.msvc.books.service.convert.entityToDto.IAuthorConverter;
import com.msvc.books.service.convert.entityToDto.IBookConverter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Optional;

@RestController
@RequestMapping("/authors")
public class AuthorController {
    @Autowired
    private IAuthorService authorService;
    @Autowired
    private IAuthorConverter<AuthorEnt, AuthorDto> authorConverter;

    @Autowired
    private IBookAuthorService bookAuthorService;

    @Autowired
    private IBookConverter<BookEnt, BookDto> bookConverter;

    @GetMapping("/{id}")
    public ResponseEntity<AuthorDto> findById(@PathVariable Integer id) throws Exception{
        Optional<AuthorEnt> authorOp = authorService.findById(id);
        if (authorOp.isEmpty()){
            throw new ModelNotFoundException("ID NOT FOUND ".concat(id.toString()));
        }

        AuthorEnt authorEnt = authorOp.get();
        AuthorDto authorDto = authorConverter.entityToDto(authorEnt);

        authorDto.setBooks(bookConverter.entityListToDtoList(findBooks(authorEnt)));

        return ResponseEntity.ok(authorDto);
    }

    private List<BookEnt> findBooks(AuthorEnt authorEnt){
        return bookAuthorService.findBooks(authorEnt);
    }


    @GetMapping
    public ResponseEntity<List<AuthorDto>> findAll() throws Exception{
        return ResponseEntity.ok(authorConverter.entityListToDtoList(authorService.findAll()));
    }

    // No tengo necesidad de guaradr un author por separado.
    @PostMapping
    public ResponseEntity<AuthorDto> save(@RequestBody AuthorDto authorDto) throws Exception{
        AuthorEnt authorEnt = authorConverter.dtoToEntity(authorDto);

        if (authorEnt.getIdAuthor() != null){
            throw new ModelKeyAutogeneratedException("The primary key is autogenerated: "
                    .concat(authorEnt.getIdAuthor().toString()));
        }

        return ResponseEntity.status(HttpStatus.CREATED).body(authorConverter.entityToDto(authorService.save(authorEnt)));
    }

    @PutMapping("/{id}")
    public ResponseEntity<AuthorDto> update(@PathVariable Integer id, @RequestBody AuthorDto authorDto) throws Exception{
        if (!authorService.existsById(id)){
            throw new ModelNotFoundException("ID NOT FOUND ".concat(id.toString()));
        }

        AuthorEnt authorEnt = authorConverter.dtoToEntity(authorDto);
        authorEnt.setIdAuthor(id);

        return ResponseEntity.ok(authorConverter.entityToDto(authorService.save(authorEnt)));

    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteById(@PathVariable Integer id) throws Exception{
        if (!authorService.existsById(id)){
            throw new ModelNotFoundException("ID NOT FOUND ".concat(id.toString()));
        }
        authorService.deleteById(id);
        return ResponseEntity.status(HttpStatus.NO_CONTENT).build();
    }

}
